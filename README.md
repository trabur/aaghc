cube and graph: level, drum, rotor, & ring mechanism
========
the cipher intercepting, code breaking, and signal jamming next level programming machine. where only a single
thread exists; true causality. which means there is only one thing flying around the room at any given time.
anyone claiming otherwise is wrong. so we say that in this cosmos true parallelism is not possible.

consistancy/availability/partition-tolerance:
- 1) gundb/database: handles signals in and out of the rotor cluster
- 2) worker/program: handles signals being sent through the rotor cluster
- 3) elixir/channel: handles signals emitted from the rotor cluster such as reflections

you get all three if:
- A) system one makes random 0s and 1s.
- B) system two balances the amount of 0s and 1s.
- C) system three keeps track of 0s and 1s.

an immune system (IS) will help figure out whats friend or fow. in our case we want to leave our friends alone
and treat our fows like negatively charged particles in a battery. big picture thinking: our IS would have been
the first thing introduced into our universe. scientists say when the universe dies there will be no more 
atoms or movement or heat. just an absolute: clean room. but i say it is the job of the IS to keep itself and
surroundings alive. after all binarry computers like 1s and 0s, true and false, friend and fow are a
nessisary part of life.

what makes enigma secure is it's rotatry mechanism. like a car speedomiter mile counter the right most wheel spins
faster than the left most wheel. however instead of rotating disks there will be rotating cubes. first there is the 
main cube; the largest. then there are sub cubes called rooms. in order to generate these the current cube is 
copied in place. then a knife perfectely cuts one of the cubes down the middle vertically and accross the 
middle horizontally into 4 equal new cubes. this cube devision can happen infinitly. 

each cube has 2 free systems. the inner wall (kernel) and the outer wall (shell). they are free because the 
lifespan of the inner wall is infinitely small while the lifespan of the outer wall is infinitely long. free
things can't be told what to do, is ture, because there is no way for a virus (master) to attach itself to
a host (slave) in order to give commands. a name that is too short or too long can't be spoken in time.

false/true:
111
101
111

true/false:
000
010
000

instead of relying on timestamps we rely on the timing of things. how long does it take to get from point A
to point B? to do this a block chain of super cube bit matrixes will work for for astronomically tight tolerances.
with each 3.6 Gigabytes block of random 1s and 0s we can use it as a base pattern to build new structures. one of
these structures is a Substitution-Permutation Network. 

it takes bits A, B, and C to navigate through bit D. meaning we need a bit to represent up and down, 
another bit to represent left and right, and a final bit to represent forward and back. however if
one system crashes such as bit A, down & up (VISA), we still want bit D to be navigatable by only
using bits B and C. what if there is a multi failure such as bit B, right and left, also crashing?
then you would be stuck to only being able to use bit C, back and forward. there is also the chance 
of each system getting jammed to one side or the other; like time pushing everyone forward leaving no
one with the ability to go back. however instead of just a vetor bit that tells us which direction
to move we want blocks 1, 2 and 3 to be navigatable through block 4. such that we digest the three
blocks bit by bit combining them to generate turn by turn directions. or rather: track movements 
through block D and backup results into blocks A, B, and C. 

website: // earth
- keyboard: input message using 1-8/26 alphabet letters
- process: (shell) master [root -> server -> branch -> node] master (shell)
- lightboard: output message using 1-8/26 alphabet letters

prototype cube: // fire
- make quary where random resources can be mined from
- collect 12 flat surfaces from the quary that are 8x8 bit for UTF8
- plugboard 2 flat surfaces together in order to form wall panels
- assemble 6 wall panels together to build outer cube surface
- add cypher channel cross wiring
- assemble 6 wall panels together to build inner cube surface
- add static cross wiring
- exit clean room

cypher channels: // water
- rotation: a virus takes over the host and replicates
- basic: expand the bits so new bits can be added between the old ones
- permutation: point all of the bits to a new set of bits
- substitution: point all of the bits at each other
- reflector: connect the bits so that they loop back around
- simple: add new bits to the beginning or ending of the old bits
- trash: garbage collect bits

cube matrix: // air
- replicate the 8x8x8 prototype cube plans so there is now a 128x128x128 cluster of them
- elect 2 master cubes from the collection of 8x8x8 times 2,097,152 and then wire them up for keyboard input
- elect 26 root cubes from the collection of 8x8x8 times 2,097,152 and then wire them up to the master cubes
- elect 10x10x10 = 1,000 server cubes from the collection of 8x8x8 times 2,097,152 and then wire them up to each root cube
- elect 24x1000 = 24,000 branch cubes from the collection of 8x8x8 times 2,097,152 and then wire them up to server cubes
- elect 360x1000 = 360,000 node cubes from the collection of 8x8x8 times 2,097,152 and then wire them up to branch cubes
- elect 6x1,024x1,024 = 1x1 times 6,291,456 or 12,288 shell cubes; give them all the same value and leave a pattern on the inside
- elect 2097152 - 360000 - 24000 - 12288 - 1000 - 26 - 2 = 1,699,836 element cubes of earth, fire, water, air, and space

point 2 point: // space
- block: this is a stack of motherboards (see ISO model below)
- motherboard: uses the concept of stars and black holes. input bits come from stars while output bits go to back holes.
- transistor: 3x3x3 by 8x8x8 by 128x128x128 super cube bit matrix

quary:
from the wall socket we have a supply of AC power. this is where we plug our computer's power
supply in order for it to get converted to DC power. that is usually wired up to your battery
and then into your motherboard and CPU. one of the programs of this mechanism is to always
keep an equal amount of 1s and 0s in the system. to do this: starting from the power that is
pushed into the input gate of the first transistor each bit is going to be tagged and tracked
through the system. the settings gate itself actually turns bits from neutral to on or off. 
the output gate wrapps these bits into sets of 8 making bytes. when a byte enters the input
gate of a transistor it is checked to see if it has an equal amount of 1s and 0s if not then
it does not pass the firewall and is released as heat. 

grab an equal amount of 1s and 0s from the garbage system:
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111

00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000

expant the letters into binary then attach a bit of garbage:
====
309e = 00110011 00110000 00111001 01100101 + 1111
f67d = 01100110 00110110 00110111 01100100 + 0000
====

the garbage is used to tell how a string is twisted (notice the 2 chunks in the middle are now flipped):
====
367e = 00110011 00110110 00110111 01100101 + 1001
f09d = 01100110 00110000 00111001 01100100 + 0110
====

there is actually a governer that controls the twisting of strings. it's purpose is to keep the 1 on top
and the 0 on the bottom. when a new char gets digested it counts the number of 1s and 0s then twists the
string to which ever direction is closer to balanced. to do this both the top and the bottom are set to a 
value of 0.5. when a 1 gets digested we adjust the counter to 1.5. however when a 0 gets digested we
adjust the counter to -1.5. after 8 bits we compare both the top and the bottom counter. if the bottom
counter is a higher number such as 3.5 and the top counter is a lower number such as 2.5 then we twist.

message:
using the JavaScript DateTime method we want to capture 2 points in time. a start time which will be the entrance
of our cube and a finish time which will be the exit of our cube. between the start and finish time is where the
user types their message.

OSI model:
a super cube bit matrix as described in the math problem below lays the foundation for our cypher infrastructure:
(128x128x128) x (8x8x8) x (3x3x3) = 28,991,029,248 bits // 3.623878656 Gigabytes

cipher infrastructure:
- Layer 13: Consious Layer     // superposition                                      // neural network
- Layer 12: Human Layer        // entanglement                                       // wiring
- Layer 11: Kernel Layer       //                                                    // central
- Layer 10: Sentence Layer     // mark point period
- Layer 9: Dictionary Layer    // ~250k words with definitions
- Layer 8: Alphabet Layer      // 26 pieces
- Layer 7: Application Layer   // 1x1x1 bit                                          // shell
- Layer 6: Presentation Layer  // 8x8x8 prototype cube                               // master
- Layer 5: Session Layer       // 16x16x16 cluster of 8x8x8                          // root     // data
- Layer 4: Transport Layer     // 32x32x32 cluster of 8x8x8                          // server   // segmentation
- Layer 3: Network Layer       // 64x64x64 cluster of 8x8x8                          // branch   // packet
- Layer 2: Data Link Layer     // 128x128x128 cluster of 8x8x8                       // node     // frame
- Layer 1: Physical Layer      // 128x128x128 cluster of 8x8x8 cluster of 3x3x3      // master   // wire
- Layer 0: Nothing Layer       // 0x0x0 bit                                          // shell

the physical layer contains a 3x3x3 or 27 cube matrixes. we randomly wire up 26 cube matrixes 
as alphabet letters to the keyboard. the first cube matrix of the physical layer is an 8 bit 
number that gives us 256 possible numbers. reversing the 8 bit number gives us another 256
possible numbers (if we keep track of the reversed bits). we now have a place for uppercase 
letters and a place for lowercase letters. however, because our cipher mechanism only works with
neutral letters: when a button (A) is pressed we want an equal amount of 1s and 0s to fire 
in the system. so we are going to cut our neutral in half in order to create positive (B) 
and negative (C). if these are put back together we get returned back to ground where our
pressed button is revealed (A). 

cipher platform:
- binary: connected or partitioned
- computer: a calculating machine
- mechanism: a system of parts working together in a machine
- peripherals: i/o, storage, and communcation devices (keyboard/lightboard, CD-ROM, and router)
- storage: a number of random bits on file that stay in place even when the computer is turned off
- memory: a number of random bits that will disappear if the computer is turned off
- motherboard: allows the cpu to talk with the memory, storage, and peripherals
- application: the action of putting something into operation
- operating system: basic functions such as scheduling tasks and device drivers
- task: file management, memory management, process management, and controlling peripheral i/o
- process: a number of threads in a shared memory space
- scheduler: decides which process runs at what points in time
- transistor: switch a thread from one state to another
- thread: take apart or put together in word sizes of 64 bits
- core: 1-2 threads working together (2.6 billion instructions per second)
- cpu: a number of cores ticking each thread at a specific clock rate
- cpu clock: produced by an external oscillator circuit
- cpu operation: fetch, decode, and execute
- cpu program: a sequence of stored instructions
- cpu CU: control unit directs the operation of the processor
- cpu processor register: a small amount of fast random bits
- cpu processor AGU: address generation unit calculates differences between processor and memory
- cpu processor ALU: arithmetic logic unit performs integer arithmetic and bitwise logic operations
- platter: cpus are projected into arrays
- silicon: stacks are sliced into platters
- sand: random bits are forged into stacks


```js
// rock     // paper   // scissors   = objects
// x        // y       // z          = dimensions
// language // number  // binary     = communications
let one = [{ 1: 0}, { 2: 1 }]
let two = [{ 1: 00}, { 2: 01 }, { 3: 10 }, { 4: 11 }]
let three = [{ 1: 000}, { 2: 001 }, { 3: 010 }, ...]
```

force: 4 x 12
========
~acceleration
mforceforcefo
arceforceforc
seforceforcef
sorceforcefor
========

point -> interval -> square -> cube:
- quadruple: a, b, c, d           // time
- tripple: x, y, z                // space
- double: latitude, longitude     // first/last
- loop: 360 degrees               // rotation
- copy: ones, zeros               // first/last
- clone: in, set, out             // space
- backup: 1, 2, 3, 4              // time

interval prototype:
start: 0, finish: 1

super cube bit matrix: 
8 bit x 8 bit x 8 bit x 8 bit = 4,294,967,296 possibilities

cube prototype:
6 sides (4,718,592 intervals x 36 squares) = 1,019,215,872 possibilities

square prototype:
72 times x 65,536 spaces = 4,718,592 possibilities

interval space:
8 bit x 8 bit = 65,536 possibilities

interval time:
2 combinations (26 letters + 0-9 numbers) = 72 possibilities

surface characteristics:
(red + orange + yellow + green + blue + purple) x (front + back + top + bottom + left + right) = 36 possibilities

cube matrix:
3 x 3 x 3 = 27 possibilities

========
algorithms:
PBKDF2: derive a key from some initial keying material
AESKW: the AES key wrap is designed to wrap or encrypt key data
HMAC: sign/verify encoded messages with a key
AAGHC: random-key algorithm,  chain cipher,            key loops: 1-infinity            Rounds: 0-1
AAGHC: lock = argon2(loop total). key = argon2(loop counter). password = argon2(key + lock). code = argon2(secret + wiring).
AAGHC: cipher secret: 1 of 26 = a --> 2 of 26 = b --> 3 of 26 = c --> etc... 
AAGHC: cipher wiring: RSA for permutation (point bits to --> new bits) and AES for substitution (point bits to = each other)
AAGHC: cipher random: code(password)
AES: symmetric-key algorithm, block cipher: 128 bits,  key sizes: 128, 192 or 256 bits, Rounds: 10, 12 or 14 (depending on key size)
AES: cipher text is a function of the current and all preceding blocks of plaintext
RSA: asymetric-key algorithm, stream cipher,           key sizes‎: ‎1,024 to 4,096 bits,  Rounds: 1

keys:
1 password = random thing
1 secret hash = hash thing // argon2(password) -> 1024 string
6 setting hashs = hash thing // argon2(secret hash + counter) -> 1024 string
1 secret key = AES(setting hashs, secret hash)
1 loopboard cipher = hmac-sha512(message, loopboard setting hash)
1 jamming cipher = hmac-sha512(message, jamming setting hash)
1 plugboards cipher = hmac-sha512(message, plugboards setting hash)
1 energy cipher = hmac-sha512(message, energy setting hash)
1 crosswire cipher = hmac-sha512(message, crosswire setting hash)
1 haywire cipher = hmac-sha512(message, haywire setting hash)
1 private hash = hash thing // argon2(secret hash) -> 1024 string
1 public hash = hash thing // argon2(private hash) -> 1024 string
1 seed = AES(setting ciphers, secret key)
1 private key = AES(seed, private hash)
1 public key = AES(seed, public hash)

settings:
1 loopboard = 8(1x360x3) + (9x3x360) + (8x9x8) + (7x5x256) + (6x7x6) + (5x11x10) + (4x19x18) + (3x27x26) + (2x9x128) = 34,476 of 65,536 combinations within 16 bits
1 jamming frequency = 2 char (use multipress) // secondary reflector (jam: "ab" will prevent input "a" from outputing "b")
8 plugboards = 0/infinity scramble -> on/off scramble -> 1-360/1-360/1-360 scramble -> 0-9 scramble -> a-z scramble -> 8 bit scramble -> haywire scramble -> 128 string scramble
4 energy units = (1-6 worker threads -> 1-1000x60x60x24 millisecond mass timeout -> 1-infinity jumps per hour speed limit) then (swap -> rotate -> flip -> switch) repeat
1 crosswire = 1 <--> 34,476 // encrypt all plain text traffic payloads that are routing between these two locations
1 haywire = 0.0 <--> 134.172 // decrypt all cipher text traffic payloads that are routing between these two locations

main reflector:
level 0: 1 drum = 360(point -> point -> point ... 3)

rotor cluster:
level 8: 9 drums = 3(binary -> binary -> binary ... 360)                                      // interval prototype
level 7: 8 drums = 9(substitution -> substitution -> substitution ... 8)                      // interval time
level 6: 7 drums = 5(address -> address -> address ... 256)                                   // super cube bit matrix
level 5: 6 drums = 7(payload -> payload -> payload ... 6)                                     // surface characteristics
level 4: 5 drums = 11(number -> number -> number ... 10)                                      // interval space
level 3: 4 drums = 19(ternary -> ternary -> ternary ... 18)                                   // square prototype
level 2: 3 drums = 27(alphabet -> alphabet -> alphabet ... 26)                                // cube matrix
level 1: 2 drums = 9(permutation -> permutation -> permutation ... 128)                       // cube prototype

process:
payload(plain text) --> keyboard --> haywire/crosswire/haywire-jam-plugboards
vvv
rotors <--reflector--> rotors
vvv
plugboards-jam-haywire/crosswire/haywire --> lightboard --> payload(cipher text)

super rotor cluster:
etc...
level 257: random # of drums = 64(entanglement -> entanglement -> entanglement ... 1TB)       // superposition
level 256: random # of drums = 64(entanglement -> entanglement -> entanglement ... 1TB)       // superposition
level 255: random # of drums = 64(entanglement -> entanglement -> entanglement ... 1TB)       // superposition
etc...
========

the Diffie–Hellman key exchange method allows two parties : that have no prior knowledge of each other 
to jointly establish a shared secret key over an insecure channel. both sides of each drum
share a common paint (the number of inputs and outputs on each rotor ring). the connections or channel is
considered insecure because only the coder knows the inside wiring while the end user might not know. if
only the outside is visible. the secret colors are the twisting of these wires (substitutions and permutations)
because the lengths from inputs to outputs are random. it takes time for signals to enter the rotor
array, reflect, and return back. so if alice is on one end with bob on the other end and they both
figure it out then they both share a common secret key. 

drums get fired on worker thread events. a load balancer round robins connections from one stack
to the next stack based on rotor timings. such as: a length of 250 from input 1 to input 1. 

after firing a drum:
- swap 0-all rings randomly
- rotate 0-all rotors randomly
- flip 0-all rotors randomly
- switch 0-all rotors randomly

point -> point -> point:
360<->360 x 360<->360 x 360<->360 ... = 1,800 wires
360! = 360 x 359 x 358 ... // infinity

alphabet -> alphabet -> alphabet:
26<->26 x 26<->26 x 26<->26 x 26<->26 ... = 16,900 wires x 3 rotor stacks = 50,700 wires
generate 52 random rings (26 unique letter + 1 left jammed <-> 26 unique letter 1 + right jammed)
keyboard input is wired up to the right most ring while the left most ring reflects by looping back around

26! = 26 x 25 x 24 x 23 ... // 4.0329146e+26 = 403,291,460,000,000,000,000,000,000
26 + 26! = 1.0485578e+28 // make each ring 27 by adding a jam letter for use as a reflector
when a signal hits a jam letter, jump to the unjammed letter, and reverse direction

SHA512: each ring produces a 128 length random hash = 1.340781e+154
SHA512: 309ecc489c12d6eb4cc40f50c902f2b4d0ed77ee511a7c7a9bcd3ca86d4cd86f989dd35bc5ff499670da34255b45b0cfd830e81f605dcf7dc5542e93ae9cd76f

from each alphabet rotor stacks we count the number of times the signal got jammed on all 26 letters
(such as: 130 times between input 1 and output 1, 150 times between input 2 and output 2, etc...)
3 alphabet rotor stacks = 2 directions (26 input letters -> timings -> 26 output letters and 1 reflector wire)


